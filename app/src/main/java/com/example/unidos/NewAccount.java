package com.example.unidos;
//changeq
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.databinding.DataBindingUtil;
import androidx.fragment.app.DialogFragment;
import androidx.lifecycle.Observer;
import androidx.lifecycle.ViewModelProvider;
import android.app.DatePickerDialog;
import android.content.Context;
import android.content.Intent;
import android.location.Location;
import android.os.Bundle;
import android.text.InputFilter;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.DatePicker;
import android.widget.ProgressBar;
import android.widget.Toast;

import java.util.Calendar;
import java.util.Date;
import java.util.Observable;

import com.example.unidos.access.Menu;
import com.example.unidos.databinding.ActivityNewAccountBinding;
import com.example.unidos.report.ReportContainer;
import com.example.unidos.repository.ReportedPerson;
import com.example.unidos.searching.Search;
import com.example.unidos.shared.Dialog;
import com.example.unidos.shared.GeneralCalendar;
import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.tasks.OnFailureListener;
import com.google.android.gms.tasks.OnSuccessListener;
import com.google.android.material.textfield.TextInputLayout;
import com.google.gson.Gson;


public class NewAccount extends AppCompatActivity {
    String selectedDate, selectedSex;
    private Messages msg = new Messages();
    private  static final String[] options = new String[]{"Hombre", "Mujer"};
    private NewAccountViewModel naViewModel;
    AutoCompleteTextView sex;
    ProgressBar progressBar;
    TextInputLayout curp;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        /** The autogenerated class LoginBinding
         * is bound with the layout activity_new_account. **/
        final ActivityNewAccountBinding naBinding = DataBindingUtil.setContentView(this, R.layout.activity_new_account);
        /** An instance of the class LoginViewModel
         * which will be bound to the activity_new_account layout **/
        naViewModel = ViewModelProvider.AndroidViewModelFactory.getInstance(this.getApplication()).create(NewAccountViewModel.class);
        final PersistentData persistentData =  new PersistentData(this);

        persistentData.checkExistence();

        /** To indicate which is the ViewModel of the Binding class **/
        naBinding.setVmNewAc(naViewModel);
        /** This class will be owner of "binding". **/
        naBinding.setLifecycleOwner(this);
        /** set list values to true or false to keep the
         * button create account disabled on app start **/
        progressBar = findViewById(R.id.progress_circular);
        naViewModel.fill();
        final GeneralCalendar calendar = new GeneralCalendar(this);
        /** Identify the AutoCompleteTextView. */
        sex = findViewById(R.id.outlined_exposed_dropdown);

        /** we'll be observing and waiting for the layout
         * component date changes. **/
        /** In this case the value will change when the
         * user presses the edit text. **/
        naViewModel.btDate.observe(this, new Observer<Boolean>() {
            @Override
            public void onChanged(Boolean s) {
                if(s){
                    calendar.getDate().addObserver(new java.util.Observer() {
                        @Override
                        public void update(Observable o, Object arg) {
                            naViewModel.date.setValue(String.valueOf(((ElementoObservable) o).getElemento()));

                        }
                    });
                    calendar.setCalendar(18,100).show();

                    /*System.out.println("DEBO MOSTRAR EL DATEPICKER");
                    DatePickerDialog datePickerDialog = setCalendar(NewAccount.this, naViewModel);
                    datePickerDialog.show();*/
                }
            }
        });

        /** we'll be observing and waiting for the layout
         * component "sex" changes.
        *   In this case the value will change when the
         *   user presses the edit text. */
        naViewModel.btSex.observe(this, new Observer<Boolean>() {
            @Override
            public void onChanged(Boolean s) {
                if(s){
                    /** configure the dropDown */
                    setDropDownMenu(naViewModel);
                    sex.showDropDown();
                }
            }
        });

        /** we'll be observing and waiting for the
         * layout component "date" changes. */
        naViewModel.date.observe(this, new Observer<String>() {
            @Override
            public void onChanged(String s) {
                Log.d("--->", s);
                /** chackDate is in charge of the
                 * validation of the typed date. **/
                naViewModel.checkDate();
            }
        });

        /** we'll be observing and waiting for the
         * layout component "sex" changes. */
        naViewModel.sex.observe(this, new Observer<String>() {
            @Override
            public void onChanged(String s) {
                Log.d("--->", s);
                /** chackSex is in charge of the validation
                 * of the typed date. **/
                naViewModel.checkSex();
            }
        });

        /** we'll be observing and waiting for the
         * layout component "curp" changes. **/
        naViewModel.curp.observe(this, new Observer<String>() {
            @Override
            public void onChanged(String s) {
                curp.getEditText().setFilters(new InputFilter[]{new InputFilter.AllCaps()});
                Log.i("--->", s);
                /** checkField is in charge of the validation of the typed date.
                 * send a 0, the method wants to know which validation apply. **/
                naViewModel.checkField(0);
            }
        });

        /** The following observers will perform
         * the same actions from the method above **/
        naViewModel.name.observe(this, new Observer<String>() {
            @Override
            public void onChanged(String s) {
                Log.i("@@@@", s);
                naViewModel.checkField(1);
            }
        });

        naViewModel.secondName.observe(this, new Observer<String>() {
            @Override
            public void onChanged(String s) {
                Log.d("--->", s);
                naViewModel.checkField(2);
            }
        });

        naViewModel.surname.observe(this, new Observer<String>() {
            @Override
            public void onChanged(String s) {
                Log.d("--->", s);
                naViewModel.checkField(3);
            }
        });

        naViewModel.secondSurname.observe(this, new Observer<String>() {
            @Override
            public void onChanged(String s) {
                Log.d("--->", s);
                naViewModel.checkField(4);
            }
        });

        naViewModel.phone.observe(this, new Observer<String>() {
            @Override
            public void onChanged(String s) {
                Log.d("--->", s);
                naViewModel.checkField(7);
            }
        });
        /** end of the same behavior. **/

        /** we'll be observing and waiting for
         * the variable "dateError" changes. */
        naViewModel.dateError.observe(this, new Observer<Boolean>() {
            /** Every time the variable changes its state will do this */
            @Override
            public void onChanged(Boolean b) {
                /** Identify the editText */
                TextInputLayout date = findViewById(R.id.TilDate);
                date.setErrorEnabled(true);
                /** show an error message */
                if (b)
                    date.setError(msg.findMessage("empty"));
                else
                    date.setError(null);
            }
        });

        /** we'll be observing and waiting for
         * the variable "sexError" changes. **/
        naViewModel.sexError.observe(this, new Observer<Boolean>() {
            /** Every time the variable changes its state will do this **/
            @Override
            public void onChanged(Boolean b) {
                /** Identify the editText **/
                TextInputLayout sex = findViewById(R.id.TilGender);
                sex.setErrorEnabled(true);
                /** show an error message */
                if (b)
                    sex.setError(msg.findMessage("empty"));
                else
                    sex.setError(null);
            }
        });

        /** we'll be observing and waiting for
         * the variable "error" changes. **/
        naViewModel.errors.observe(this, new Observer<String>() {
            @Override
            /** get the updated value **/
            public void onChanged(String s) {
                /** Identify the fields in the layout **/
                curp = findViewById(R.id.TilCurp);
                curp.setErrorEnabled(true);
                TextInputLayout name = findViewById(R.id.TilName);
                name.setErrorEnabled(true);
                TextInputLayout secondName = findViewById(R.id.TilName2);
                secondName.setErrorEnabled(true);
                TextInputLayout surname = findViewById(R.id.TilLastName1);
                surname.setErrorEnabled(true);
                TextInputLayout secondSurname = findViewById(R.id.TilLastName2);
                secondSurname.setErrorEnabled(true);
                TextInputLayout phone = findViewById(R.id.TilPhone);
                phone.setErrorEnabled(true);
                /** Lets check the action to execute. **/
                switch (s){
                    /** The field "CURP" is empty **/
                    case "emptyCurp":
                        /** Show message error. **/
                        curp.setError(msg.findMessage("empty"));
                        break;
                        /** The value "CURP" is correct **/
                    case "fillCurp":
                        /** disappear the error **/
                        curp.setErrorEnabled(false);
                        break;
                        /** the CURP value doesn´t match
                         * with the regular expression. **/
                    case "wrongSyntaxCurp":
                        System.out.println("holaa");
                        /** enable the error section and
                         * show error message under the field. **/
                        curp.setErrorEnabled(true);
                        curp.setError(msg.findMessage("noCURPmatch"));
                        break;
                        /** The name field is empty**/
                    case "emptyName":
                        /** show error message under the field**/
                        name.setError(msg.findMessage("empty"));
                        break;
                        /** the value of the name
                         * matches the regular expression */
                    case "fillName":
                        /** Disappear error message. **/
                        name.setErrorEnabled(false);
                        break;
                    /** the value of the name doesn´t match
                     * the regular expression **/
                    case "wrongSyntaxName":
                        name.setError(msg.findMessage("noNameMatch"));
                        break;
                    /** the value of the secondName doesn´t
                     * match the regular expression **/
                    case "wrongSyntaxName2":
                        secondName.setError(msg.findMessage("noNameMatch"));
                        break;
                    /** the value of the name2 matches
                     * the regular expression **/
                    case "fillName2":
                        secondName.setErrorEnabled(false);
                        break;
                        /** the surname field is empty **/
                    case "emptySurname":
                        surname.setError(msg.findMessage("empty"));
                        break;
                    /** the surname value matches
                     * the regular expression **/
                    case "fillSurname":
                        surname.setErrorEnabled(false);
                        break;
                    /** the surname value doesn't match
                     *  the regular expression **/
                    case "wrongSyntaxSurname":
                        surname.setError(msg.findMessage("noNameMatch"));
                        break;
                    /** the secondSurname value doesn't match
                     * the regular expression **/
                    case "wrongSyntaxSurname2":
                        secondSurname.setError(msg.findMessage("noNameMatch"));
                        break;
                    /** the secondSurname value matches
                     *  the regular expression **/
                    case "fillSurname2":
                        secondSurname.setErrorEnabled(false);
                        break;
                        /** the phone field is empty **/
                    case "emptyPhone":
                        phone.setError(msg.findMessage("empty"));
                        break;
                    /** the phone value matches the regular expression **/
                    case "fillPhone":
                        phone.setErrorEnabled(false);
                        break;
                    /** the phone value doesn't match
                     * the regular expression **/
                    case "wrongSyntaxPhone":
                        phone.setError(msg.findMessage("noPhoneMatch"));
                        break;
                }
            }
        });

        /** we'll be observing and waiting
         * for the variable "actionBtNewAcc" changes. **/
        naViewModel.actionBtNewAcc.observe(this, new Observer<String>() {
            @Override
            public void onChanged(String s) {
                Log.i("---> pb", s);
                switch (s){
                    /** Just show the progress bar **/
                    case "showProgressBar":
                        progressBar.setVisibility(View.VISIBLE);
                        naViewModel.setContext(NewAccount.this);
                        break;
                        /** Phone verification fail **/
                    case "hideProgressBar:fail":
                        /** Show error message **/
                        newAccountDoSomething(msg.findMessage("phoneVerifFail"));
                        break;
                        /** The CURP is already registered. **/
                    case "hideProgressBar:existingCURP":
                        /** Show error message **/
                        newAccountDoSomething(msg.findMessage("usrFound"));
                        break;
                        /** Something wrong happend on a firebase operation. **/
                    case "hideProgresBar:operationFail":
                        newAccountDoSomething(msg.findMessage("fail"));
                        break;
                        /** Succesful insertion **/
                    case "hideProgressBar:successInserting":
                        /** show message **/
                        newAccountDoSomething(msg.findMessage("opSuccess"));
                        /** call method to store the CURP and keep log */
                        persistentData.setValues(naViewModel.getCURP());
                        determineActivityToStart();
                        //goToMainActivity();
                        break;
                        /** The phone is already registered **/
                    case "hideProgressBar:existingPhone":
                        newAccountDoSomething(msg.findMessage("phoneFound"));
                        break;
                        /** The Internet connection is not stable **/
                    case "hideProgressBar:hasntInternet":
                        newAccountDoSomething(msg.findMessage("badConn"));
                        break;
                        /** The phone is not connected to Internet. **/
                    case "hideProgressBar:noConnected":
                        newAccountDoSomething(msg.findMessage("noConn"));
                        break;
                }
            }
        });


        naViewModel.isBtnPressed.observe(this, new Observer<Boolean>() {
            @Override
            public void onChanged(Boolean isPressed) {
                if(isPressed){
                    DialogFragment dialog = new Dialog(true);
                    dialog.show(getSupportFragmentManager(), "dialog");
                }
            }
        });
    }

    private void checkDistance(Bundle bundle, LatLng userLoc){
        naViewModel.opResult.observe(this, new Observer<Integer>() {
            @Override
            public void onChanged(Integer res) {
                switch (res){
                    case 1:
                        goToPersonInfo(naViewModel.getPerson());
                        break;
                    case -1:
                        showMessage(Messages.MSG003_1_OP_FAIL);
                        break;
                    case -2:
                        showMessage(Messages.MSG003_1_OP_FAIL);
                        break;
                    case -3:
                        goToListPeople();
                }
            }
        });

        naViewModel.getIfPersonNear((String) bundle.get("CURP"),
                new LatLng(Double.parseDouble(bundle.getString("lat")),
                        Double.parseDouble(bundle.getString("lon"))),
                userLoc
        );
    }

    private void getUserLocation(final Bundle bundle){
        FusedLocationProviderClient locationClient = LocationServices.getFusedLocationProviderClient(this);
        Log.i("^^^{ ", "LETS GET USER LOC");
        try {
            locationClient.getLastLocation()
                    .addOnSuccessListener(new OnSuccessListener<Location>() {
                        @Override
                        public void onSuccess(Location location) {
                            Log.i("^^^{ ", "SUCCESS");
                            // GPS location can be null if GPS is switched off
                            if (location != null) {
                                Log.i("^^^{  ", "We got the location");
                                checkDistance(bundle, new LatLng(
                                        location.getLatitude(),
                                        location.getLongitude()
                                ));
                            }else if(location == null){
                                //showMessage(Messages.MSG007_2_LOCATION_FAIL);
                                Log.i("^^^{ ", "Loc is null");
                                goToListPeople();
                            }
                        }
                    })
                    .addOnFailureListener(new OnFailureListener() {
                        @Override
                        public void onFailure(@NonNull Exception e) {
                            Log.i("^^^{ ", "Error trying to get last GPS location");
                            e.printStackTrace();
                            goToListPeople();
                        }
                    });
        } catch (SecurityException e) { e.printStackTrace(); }
    }

    private void determineActivityToStart() {
        if (getIntent().getExtras() != null) {
            Bundle bundle = getIntent().getExtras();

            Log.i("^^^{ ", "EXTRAS NOT NULL");
            if (bundle.containsKey("click_action") || bundle.containsKey("log")) {
                Log.i("^^^{ in determact", "Notif has intent name");
                getUserLocation(bundle);
            }
        } else {
            Log.i("^^^{ ", "EXTRAS R NULL");
            goToMainActivity();
        }
    }

    private void goToMainActivity(){
        Intent i = new Intent(this, Menu.class);
        startActivity(i);
    }

    private void goToPersonInfo(ReportedPerson person){
        /*ReportedPerson person = new ReportedPerson();
        person.setName("Juana");
        person.setName2("La Cubana");
        person.setFound(false);
        person.setMissingPlace(15);
        person.setRecSeenDate(Calendar.getInstance().getTime());*/

        Intent i = new Intent(this, ReportContainer.class);
        i.putExtra("SelPerson", new Gson().toJson(person));
        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        //i.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
        startActivity(i);
    }

    private void goToListPeople(){
        Intent i = new Intent(this, Search.class);
        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        startActivity(i);
    }

    /** Show informative toast messages. **/
    public void newAccountDoSomething(String message){
        progressBar.setVisibility(View.GONE);
        Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
    }

    public DatePickerDialog setCalendar(Context context, final NewAccountViewModel newAccountViewModel){
        final Calendar c = Calendar.getInstance();
        /** get the day, month and year **/
        final int mYear = c.get(Calendar.YEAR), mMonth = c.get(Calendar.MONTH), mDay = c.get(Calendar.DAY_OF_MONTH);
        /** The listener indicate the user has finished selecting a date. **/
        DatePickerDialog datePickerDialog=new DatePickerDialog(
                this, new DatePickerDialog.OnDateSetListener() {
            @Override
            public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) {
                /** set a date right format to a variable. **/
                if(dayOfMonth<10 && month<10) {
                    selectedDate = "0"+dayOfMonth + "/0" + (month+1) + "/" + year;
                }else if(dayOfMonth<10)
                    selectedDate = "0"+dayOfMonth + "/" + (month+1) + "/" + year;
                else if(month<10)
                    selectedDate = dayOfMonth + "/0" + (month+1) + "/" + year;
                else
                    selectedDate = ""+dayOfMonth + "/" + (month+1) + "/" + year;
                /** call to the method in order to pass the date selected on every click **/
                newAccountViewModel.setDate(selectedDate);
            }
        }, mYear, mMonth, mDay);

        /** Configure the date to display, the system wont allow register minors **/
        Date today= new Date();
        c.setTime(today);
        c.add(Calendar.YEAR, -18);
        long maxDate = c.getTime().getTime();
        datePickerDialog.getDatePicker().setMaxDate(maxDate);
        c.setTime(today);
        c.add(Calendar.YEAR, -100);
        long minDate= c.getTime().getTime();
        datePickerDialog.getDatePicker().setMinDate(minDate);
        return datePickerDialog;
    }


    /** to configure the dropdown menu */
    public void setDropDownMenu(final NewAccountViewModel navm){
        System.out.println("DEBO MOSTRAR EL MENÚ");
        ArrayAdapter<String> adapter = new ArrayAdapter<>(NewAccount.this, R.layout.dropdown_menu_popup_item, options);
        sex.setAdapter(adapter);
        sex.setOnItemClickListener(new AdapterView.OnItemClickListener(){
            /** To know which option was selected. **/
            public void onItemClick(AdapterView<?> arg0, View arg1, int arg2, long arg3){
                selectedSex = (String) arg0.getItemAtPosition(arg2);
                Log.i("SELECTED TEXT WAS---->", selectedSex);
                /** To send the value to NewAccountViewModel **/
                navm.sex.setValue(selectedSex);
            }
        });
    }

    public void method(){
        Log.i("%%%%%", "Im back");
        progressBar.setVisibility(View.VISIBLE);
        Connection connection = new Connection(this);

        /** If the phone hasn´t connection**/
        if(connection.isNotConnected())
        /** Inform the observer it must show an error message
         and hide the progress bar. */
            newAccountDoSomething(msg.findMessage("noConn"));
        else if(connection.checkConnection()){
            /** Is the connection stable?**/
            System.out.println("Sí cuenta con la calidad deseada");
            /** Continue with the register. **/
            naViewModel.register();
        } else{
            /**Probably the connection is unstable. **/
            /**Inform the observer it must show the progress bar
             * and display an error message. */
            newAccountDoSomething(msg.findMessage("badConn"));
        }
    }

    public void showMessage(String message){
        progressBar.setVisibility(View.GONE);
        Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG).show();
    }

}
